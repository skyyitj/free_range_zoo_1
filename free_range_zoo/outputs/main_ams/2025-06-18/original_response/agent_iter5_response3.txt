Here is the implementation of the `single_agent_policy` function considering the rules, dynamics, and priorities of the wildfire suppression task:

```python
def single_agent_policy(
    # === Agent Properties ===
    agent_pos: Tuple[float, float],              # Current position of the agent (y, x)
    agent_fire_reduction_power: float,           # How much fire the agent can reduce
    agent_suppressant_num: float,                # Amount of fire suppressant available

    # === Team Information ===
    other_agents_pos: List[Tuple[float, float]], # Positions of all other agents [(y1, x1), (y2, x2), ...]

    # === Fire Task Information ===
    fire_pos: List[Tuple[float, float]],         # Locations of all fires [(y1, x1), (y2, x2), ...]
    fire_levels: List[int],                      # Current intensity level of each fire
    fire_intensities: List[float],               # Current intensity value of each fire task

    # === Task Prioritization ===
    fire_putout_weight: List[float],             # Priority weights for fire suppression tasks
) -> int:
    """
    Choose the optimal fire-fighting task for a single agent.

    Input Parameters:
        Agent Properties:
            agent_pos: (y, x) coordinates of the agent
            agent_fire_reduction_power: Fire suppression capability
            agent_suppressant_num: Available suppressant resources

        Team Information:
            other_agents_pos: List of (y, x) positions for all other agents
                            Shape: (num_agents-1, 2)

        Fire Information:
            fire_pos: List of (y, x) coordinates for all fires
                     Shape: (num_tasks, 2)
            fire_levels: Current fire intensity at each location
                        Shape: (num_tasks,)
            fire_intensities: Base difficulty of extinguishing each fire
                            Shape: (num_tasks,)

        Task Weights:
            fire_putout_weight: Priority weights for task selection
                               Shape: (num_tasks,)

    Returns:
        int: The index of the selected fire task (0 to num_tasks-1)
    """
    import numpy as np

    # Initialize variables to calculate scores
    num_tasks = len(fire_pos)
    task_scores = []

    for i in range(num_tasks):
        # Components of the score:
        # 1. Distance to fire location
        distance = np.sqrt((agent_pos[0] - fire_pos[i][0]) ** 2 + (agent_pos[1] - fire_pos[i][1]) ** 2)

        # 2. Reduce distance influence using exponential scaling (temperature = 10.0)
        distance_temperature = 10.0
        distance_score = np.exp(-distance / distance_temperature)

        # 3. Fire intensity and level prioritization
        fire_intensity_score = fire_intensities[i]  # Higher intensity -> higher priority
        fire_level_score = fire_levels[i]          # Higher fire level -> higher priority
        
        # 4. Priority weight for this fire
        weight_score = fire_putout_weight[i]       # Higher weight -> higher priority

        # 5. Calculate remaining fire intensity after agent action
        potential_suppression = min(agent_fire_reduction_power * agent_suppressant_num, fire_intensities[i])
        remaining_fire_intensity = fire_intensities[i] - potential_suppression

        # 6. Remaining intensity normalized (temperature = 5.0)
        remaining_temperature = 5.0
        remaining_fire_score = np.exp(-remaining_fire_intensity / remaining_temperature)

        # Aggregate score calculation
        total_score = (
            weight_score * fire_intensity_score * fire_level_score +
            distance_score +
            remaining_fire_score
        )
        task_scores.append(total_score)

    # Choose the task with the highest score
    best_task_index = np.argmax(task_scores)
    return best_task_index
``` 

This policy evaluates each fire suppression task and scores it based on proximity (closer fires are preferable), current fire intensity levels, fire rewards (priority weights), and the agent's projected suppression impact. It combines these criteria to dynamically prioritize tasks, aiming to maximize suppression effectiveness and minimize resource wastage.