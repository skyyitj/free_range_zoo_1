```python
def single_agent_policy(
    agent_pos: Tuple[float, float], 
    agent_fire_reduction_power: float,
    agent_supressant_num: float, 
    other_agents_pos: List[Tuple[float, float]], 
    fire_pos: List[Tuple[float, float]], 
    fire_levels: List[int], 
    fire_intensities: List[float],
    fire_putout_weight: List[float]
) -> int:
    num_tasks = len(fire_pos)
    best_task_index = -1
    highest_score = float('-inf')

    # Adjust the temperature constants based on evaluation results for balancing
    distance_temp = 0.5  # Reducing the impact of distance to promote closer, effective task targeting
    effectiveness_temp = 1.0  # Lowering to balance the over-optimism for potential effectiveness
    importance_temp = 3.0  # Increasing the importance effect to adhere better to task prioritization
    suppressant_eff_temp = 2.0  # Increase to better balance the use of suppressants

    for task_index in range(num_tasks):
        fire = fire_pos[task_index]
        fire_intensity = fire_intensities[task_index]
        
        # Calculate Euclidean distance to each fire task
        distance = np.sqrt((agent_pos[0] - fire[0])**2 + (agent_pos[1] - fire[1])**2)

        # Calculate what suppressant amount can be effectively managed within the resource limits
        advisable_suppressant_use = min(fire_intensity / agent_fire_reduction_power if agent_fire_reduction_power > 0 else float('inf'), agent_supressant_num)
        
        # Compute potential effectiveness if this fire is targeted
        potential_effectiveness = agent_fire_reduction_power * advisable_suppressant_use
        
        # Calculate suppressant efficiency based on effective usage forecast
        if advisable_suppressant_use > 0:
            suppressant_efficiency = potential_effectiveness / advisable_suppressant_use
        else:
            suppressant_efficiency = 0 
        
        # Record the importance of targeting this specific fire
        importance_weight = fire_putout_weight[task_index]
        
        # Compose the task score considering the adjusted components
        task_score = (
            -np.log(distance + 1) / distance_temp +
            np.log(potential_effectiveness + 1) * effectiveness_temp +
            np.log(suppressant_efficiency + 1) * suppressant_eff_temp +
            importance_weight * importance_temp
        )
        
        # Identify the best task based on the computed scores
        if task_score > highest_score:
            highest_score = task_score
            best_task_index = task_index

    return best_task_index
```

### Rationale for Revisions:
1. **Distance Temperature**: Given possible lower rewards, proximity may need to be targeted more confidently. A reduction in the temperature helps reduce reluctance in choosing fires close to the agent by making distance less punitive.
2. **Effectiveness Temperature**: Previously, there might be too high optimism for achieving effectiveness; reducing helps balance actual achievable results and desired outcomes.
3. **Importance Temperature**: Increase to emphasize according to prioritized weights, to make sure high-priority targets aren't overlooked.
4. **Suppressant Efficiency Temperature**: This is adjusted up to give better weight to using suppressant efficiently, especially insightful if suppressant usage metrics came unsatisfactory in initial trials. 

Through this rebalancing, the function may now do a better job concentrating on crucial fires both in terms of risk and reward, all while managing resources more prudently. These changes aim to broadly fine-tune response in order to enhance overall performance in suppression, efficiency, and resource conservation.