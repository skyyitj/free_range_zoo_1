```python
def single_agent_policy(
    agent_pos: Tuple[float, float], 
    agent_fire_reduction_power: float, 
    agent_suppressant_num: float, 

    other_agents_pos: List[Tuple[float, float]], 

    fire_pos: List[Tuple[float, float]], 
    fire_levels: List[int], 
    fire_intensities: List[float], 

    fire_putout_weight: List[float]
) -> int:

    max_score = float('-inf')
    best_fire = None
    temperature1 = 0.2  # adjusts the weight towards higher fire weights
    temperature2 = 0.3  # adjusts the weight towards shorter distances

    for i, (fire_position, fire_level, fire_intensity, fire_weight) in enumerate(zip(fire_pos, fire_levels, fire_intensities, fire_putout_weight)):
        
        # Distance-based factor for task selection
        dist = ((fire_position[0]-agent_pos[0])**2 + (fire_position[1]-agent_pos[1])**2)**0.5 / (agent_suppressant_num+1)
        
        # Firefighting efficiency factor in task selection
        suppression_power = agent_fire_reduction_power * agent_suppressant_num / (fire_intensity + 1)
        
        # Score calculation considering prioritization weight, firefighting efficiency, and distance factor
        # Include the fire level as an additional factor to prioritize fires with higher levels
        # Distinct temperature parameters are set for fire weight and distance to fine-tune their influence on the score computation
        score = np.exp((fire_weight * suppression_power / temperature1) / temperature2 / dist + fire_level)

        if score > max_score:
            max_score = score
            best_fire = i
    return best_fire
```

Here we use two temperature parameters to separately fine-tune the influence of fire weight and distance on the score computation, which respectively reflect the priority of extinguishing each fire and the cost of moving to the fire. This would help the agent to make a more balanced decision between prioritizing fires with higher weights and fires that are closer.