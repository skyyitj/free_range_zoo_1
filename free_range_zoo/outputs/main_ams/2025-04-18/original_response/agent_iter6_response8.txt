```python
def single_agent_policy(
    agent_pos: Tuple[float, float], 
    agent_fire_reduction_power: float, 
    agent_suppressant_num: float, 

    other_agents_pos: List[Tuple[float, float]], 

    fire_pos: List[Tuple[float, float]], 
    fire_levels: List[int], 
    fire_intensities: List[float], 

    fire_putout_weight: List[float]
) -> int:

    max_score = -float('inf')
    best_fire = None
    temperature_distance = 0.05  
    temperature_suppression = 0.03  

    for i, (fire_position, fire_level, fire_intensity, fire_weight) in enumerate(zip(fire_pos, fire_levels, fire_intensities, fire_putout_weight)):

        dist = ((fire_position[0]-agent_pos[0])**2 + (fire_position[1]-agent_pos[1])**2)**0.5 / (agent_suppressant_num+1)
        suppression_power = agent_fire_reduction_power * agent_suppressant_num / (fire_intensity + 1)
        
        score = np.exp((fire_weight * suppression_power / (dist + 1) * np.exp(-fire_level * temperature_suppression)) / temperature_distance)
        
        if score > max_score:
            max_score = score
            best_fire = i

    return best_fire
```
In the latest revision, we introduce two temperature variables, `temperature_distance` and `temperature_suppression`, to handle the impacts of distance and suppression power separately. 
`temperature_distance` decides the importance of distance in the score calculation by scaling down the exponent in the distance-related part of the score equation. A higher `temperature_distance` will make the score less sensitive to the distance, which lets agent focus more on closer fires. 
`temperature_suppression` determines the weight of fire level in suppression power computation. A higher `temperature_suppression` means the agent will pay more attention to the fire with higher level, to avoid the fire from burning out due to constant high fire level. This also makes the agent use suppressant more effectively. 
Both of these improvements should help the agent choose the most critical fires and conserve resources.