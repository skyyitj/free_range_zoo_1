Understanding the detailed scenario for the wildfire suppression system above, let's create an efficient policy function for a single agent to optimally extinguish fires.

We'll consider the following features from the scenario for our scoring strategy:

- **Distance:** Closer fires are preferable (minimize travel time).
- **Intensity Reduction:** Targeting fires where the agent can make a significant impact is beneficial.
- **Resource Utilization:** Prioritize fires based on agent's available suppressant resources.
- **Task Priority:** Use provided fire_putout_weight to enhance the importance of certain tasks.

The aim is to compute a score for each possible fire task and select the one with the highest score, effectively utilizing available resources and focusing on critical task points.

We'll implement this using numpy for efficient computation with the following steps:
1. Calculate the Euclidean distance from the agent to each fire.
2. Compute an effectiveness ratio reflecting how much the agent can reduce the fire intensity relative to the current intensity.
3. Compute a resource ratio showing how much of the agent's suppressant resource would be used.
4. Consider the provided priority weights for each fire.
5. Integrate these factors into a scoring formula.

```python
import numpy as np
from typing import Tuple, List

def single_agent_policy(
    agent_pos: Tuple[float, float],
    agent_fire_reduction_power: float,
    agent_suppressant_num: float,
    other_agents_pos: List[Tuple[float, float]],
    fire_pos: List[Tuple[float, float]],
    fire_levels: List[int],
    fire_intensities: List[float],
    fire_putout_weight: List[float],
) -> int:
    
    num_tasks = len(fire_pos)
    
    if num_tasks == 0:
        return -1  # No tasks available

    # Arrays from the lists
    fire_positions = np.array(fire_pos)
    agent_position = np.array(agent_pos)
    
    # Calculate distances from agent to each fire
    distance = np.linalg.norm(fire_positions - agent_position, axis=1)

    # Calculate how effectively the agent can impact each fire
    max_possible_suppression = agent_fire_reduction_power * agent_suppressant_num
    effectiveness = np.clip(max_possible_suppression - np.array(fire_intensities), 0, None)
    
    # Normalization and transformation parameters
    temp_distance = 1.0
    temp_effectiveness = 3.0
    temp_suppressant = 2.0
    
    # Higher weight should result in higher score, inverse for distance
    normalized_distances = np.exp(-temp_distance * distance / distance.mean())
    normalized_effectiveness = np.exp(temp_effectiveness * effectiveness / effectiveness.mean() if effectiveness.mean() > 0 else effectiveness)
    normalized_weights = np.array(fire_putout_weight)
    
    # Combine components into a scoring system
    # Adding an emphasis on effectiveness and prioritized weights
    scores = (normalized_effectiveness * normalized_weights * normalized_distances)
    
    # Choose the fire with the highest score
    chosen_fire_index = np.argmax(scores)
    
    return chosen_fire_index
```

This function addresses the problem through a scoring system based on distance, effectiveness (how well the agent can suppress a fire considering its intensity and the agent's suppressant capability), and the importance of each fire task (given by `fire_putout_weight`). The use of exponential scaling and averages help to manage the relative importance, keeping the scores balanced and focused towards the goals mentioned in the provided task scenario.